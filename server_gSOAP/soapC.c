/* soapC.c
   Generated by gSOAP 2.8.95 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.95 2019-11-27 08:57:09 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_wsdd__FaultCodeType:
		return soap_in_wsdd__FaultCodeType(soap, tag, NULL, "wsdd:FaultCodeType");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_in_wsa__FaultSubcodeValues(soap, tag, NULL, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_in_wsa__RelationshipTypeValues(soap, tag, NULL, "wsa:RelationshipTypeValues");
	case SOAP_TYPE_wsdd__AppSequenceType:
		return soap_in_wsdd__AppSequenceType(soap, tag, NULL, "wsdd:AppSequenceType");
	case SOAP_TYPE_wsdd__SigType:
		return soap_in_wsdd__SigType(soap, tag, NULL, "wsdd:SigType");
	case SOAP_TYPE_wsdd__SecurityType:
		return soap_in_wsdd__SecurityType(soap, tag, NULL, "wsdd:SecurityType");
	case SOAP_TYPE_wsdd__ScopesType:
		return soap_in_wsdd__ScopesType(soap, tag, NULL, "wsdd:ScopesType");
	case SOAP_TYPE_wsdd__ResolveMatchType:
		return soap_in_wsdd__ResolveMatchType(soap, tag, NULL, "wsdd:ResolveMatchType");
	case SOAP_TYPE_wsdd__ResolveMatchesType:
		return soap_in_wsdd__ResolveMatchesType(soap, tag, NULL, "wsdd:ResolveMatchesType");
	case SOAP_TYPE_wsdd__ResolveType:
		return soap_in_wsdd__ResolveType(soap, tag, NULL, "wsdd:ResolveType");
	case SOAP_TYPE_wsdd__ProbeMatchType:
		return soap_in_wsdd__ProbeMatchType(soap, tag, NULL, "wsdd:ProbeMatchType");
	case SOAP_TYPE_wsdd__ProbeMatchesType:
		return soap_in_wsdd__ProbeMatchesType(soap, tag, NULL, "wsdd:ProbeMatchesType");
	case SOAP_TYPE_wsdd__ProbeType:
		return soap_in_wsdd__ProbeType(soap, tag, NULL, "wsdd:ProbeType");
	case SOAP_TYPE_wsdd__ByeType:
		return soap_in_wsdd__ByeType(soap, tag, NULL, "wsdd:ByeType");
	case SOAP_TYPE_wsdd__HelloType:
		return soap_in_wsdd__HelloType(soap, tag, NULL, "wsdd:HelloType");
	case SOAP_TYPE_wsa__Relationship:
		return soap_in_wsa__Relationship(soap, tag, NULL, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_in_wsa__ServiceNameType(soap, tag, NULL, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_in_wsa__ReferenceParametersType(soap, tag, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_in_wsa__ReferencePropertiesType(soap, tag, NULL, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_in_wsa__EndpointReferenceType(soap, tag, NULL, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTowsdd__ResolveMatchesType:
		return soap_in_PointerTowsdd__ResolveMatchesType(soap, tag, NULL, "wsdd:ResolveMatchesType");
	case SOAP_TYPE_PointerTowsdd__ResolveType:
		return soap_in_PointerTowsdd__ResolveType(soap, tag, NULL, "wsdd:ResolveType");
	case SOAP_TYPE_PointerTowsdd__ProbeMatchesType:
		return soap_in_PointerTowsdd__ProbeMatchesType(soap, tag, NULL, "wsdd:ProbeMatchesType");
	case SOAP_TYPE_PointerTowsdd__ProbeType:
		return soap_in_PointerTowsdd__ProbeType(soap, tag, NULL, "wsdd:ProbeType");
	case SOAP_TYPE_PointerTowsdd__ByeType:
		return soap_in_PointerTowsdd__ByeType(soap, tag, NULL, "wsdd:ByeType");
	case SOAP_TYPE_PointerTowsdd__HelloType:
		return soap_in_PointerTowsdd__HelloType(soap, tag, NULL, "wsdd:HelloType");
	case SOAP_TYPE_PointerTowsdd__AppSequenceType:
		return soap_in_PointerTowsdd__AppSequenceType(soap, tag, NULL, "wsdd:AppSequenceType");
	case SOAP_TYPE__wsdd__Types:
	{	char **s;
		s = soap_in__wsdd__Types(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTowsdd__SigType:
		return soap_in_PointerTowsdd__SigType(soap, tag, NULL, "wsdd:SigType");
	case SOAP_TYPE_PointerTowsdd__ResolveMatchType:
		return soap_in_PointerTowsdd__ResolveMatchType(soap, tag, NULL, "wsdd:ResolveMatchType");
	case SOAP_TYPE_PointerTowsdd__ProbeMatchType:
		return soap_in_PointerTowsdd__ProbeMatchType(soap, tag, NULL, "wsdd:ProbeMatchType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTowsdd__ScopesType:
		return soap_in_PointerTowsdd__ScopesType(soap, tag, NULL, "wsdd:ScopesType");
	case SOAP_TYPE_wsdd__FaultCodeOpenType:
	{	char **s;
		s = soap_in_wsdd__FaultCodeOpenType(soap, tag, NULL, "wsdd:FaultCodeOpenType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsdd__UriListType:
	{	char **s;
		s = soap_in_wsdd__UriListType(soap, tag, NULL, "wsdd:UriListType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsdd__QNameListType:
	{	char **s;
		s = soap_in_wsdd__QNameListType(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_in_PointerTo_wsa__FaultTo(soap, tag, NULL, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_in_PointerTo_wsa__ReplyTo(soap, tag, NULL, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_in_PointerTo_wsa__From(soap, tag, NULL, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_in_PointerTo_wsa__RelatesTo(soap, tag, NULL, "wsa:RelatesTo");
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_in_PointerTowsa__ServiceNameType(soap, tag, NULL, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_in_PointerTo_QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_in_PointerTowsa__ReferenceParametersType(soap, tag, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, NULL, "wsa:ReferencePropertiesType");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:FaultCodeType"))
		{	*type = SOAP_TYPE_wsdd__FaultCodeType;
			return soap_in_wsdd__FaultCodeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultSubcodeValues"))
		{	*type = SOAP_TYPE_wsa__FaultSubcodeValues;
			return soap_in_wsa__FaultSubcodeValues(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelationshipTypeValues"))
		{	*type = SOAP_TYPE_wsa__RelationshipTypeValues;
			return soap_in_wsa__RelationshipTypeValues(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:AppSequenceType"))
		{	*type = SOAP_TYPE_wsdd__AppSequenceType;
			return soap_in_wsdd__AppSequenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:SigType"))
		{	*type = SOAP_TYPE_wsdd__SigType;
			return soap_in_wsdd__SigType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:SecurityType"))
		{	*type = SOAP_TYPE_wsdd__SecurityType;
			return soap_in_wsdd__SecurityType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ScopesType"))
		{	*type = SOAP_TYPE_wsdd__ScopesType;
			return soap_in_wsdd__ScopesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ResolveMatchType"))
		{	*type = SOAP_TYPE_wsdd__ResolveMatchType;
			return soap_in_wsdd__ResolveMatchType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ResolveMatchesType"))
		{	*type = SOAP_TYPE_wsdd__ResolveMatchesType;
			return soap_in_wsdd__ResolveMatchesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ResolveType"))
		{	*type = SOAP_TYPE_wsdd__ResolveType;
			return soap_in_wsdd__ResolveType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ProbeMatchType"))
		{	*type = SOAP_TYPE_wsdd__ProbeMatchType;
			return soap_in_wsdd__ProbeMatchType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ProbeMatchesType"))
		{	*type = SOAP_TYPE_wsdd__ProbeMatchesType;
			return soap_in_wsdd__ProbeMatchesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ProbeType"))
		{	*type = SOAP_TYPE_wsdd__ProbeType;
			return soap_in_wsdd__ProbeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ByeType"))
		{	*type = SOAP_TYPE_wsdd__ByeType;
			return soap_in_wsdd__ByeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:HelloType"))
		{	*type = SOAP_TYPE_wsdd__HelloType;
			return soap_in_wsdd__HelloType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:Relationship"))
		{	*type = SOAP_TYPE_wsa__Relationship;
			return soap_in_wsa__Relationship(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ServiceNameType"))
		{	*type = SOAP_TYPE_wsa__ServiceNameType;
			return soap_in_wsa__ServiceNameType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa__ReferenceParametersType;
			return soap_in_wsa__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferencePropertiesType"))
		{	*type = SOAP_TYPE_wsa__ReferencePropertiesType;
			return soap_in_wsa__ReferencePropertiesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa__EndpointReferenceType;
			return soap_in_wsa__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsdd__Types;
			s = soap_in__wsdd__Types(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:FaultCodeOpenType"))
		{	char **s;
			*type = SOAP_TYPE_wsdd__FaultCodeOpenType;
			s = soap_in_wsdd__FaultCodeOpenType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:UriListType"))
		{	char **s;
			*type = SOAP_TYPE_wsdd__UriListType;
			s = soap_in_wsdd__UriListType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_wsdd__QNameListType;
			s = soap_in_wsdd__QNameListType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsdd:MetadataVersion"))
		{	*type = SOAP_TYPE__wsdd__MetadataVersion;
			return soap_in__wsdd__MetadataVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReplyAfter"))
		{	*type = SOAP_TYPE__wsa__ReplyAfter;
			return soap_in__wsa__ReplyAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:AppSequence"))
		{	*type = SOAP_TYPE__wsdd__AppSequence;
			return soap_in__wsdd__AppSequence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Sig"))
		{	*type = SOAP_TYPE__wsdd__Sig;
			return soap_in__wsdd__Sig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Security"))
		{	*type = SOAP_TYPE__wsdd__Security;
			return soap_in__wsdd__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Scopes"))
		{	*type = SOAP_TYPE__wsdd__Scopes;
			return soap_in__wsdd__Scopes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ResolveMatches"))
		{	*type = SOAP_TYPE__wsdd__ResolveMatches;
			return soap_in__wsdd__ResolveMatches(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Resolve"))
		{	*type = SOAP_TYPE__wsdd__Resolve;
			return soap_in__wsdd__Resolve(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:ProbeMatches"))
		{	*type = SOAP_TYPE__wsdd__ProbeMatches;
			return soap_in__wsdd__ProbeMatches(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Probe"))
		{	*type = SOAP_TYPE__wsdd__Probe;
			return soap_in__wsdd__Probe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Bye"))
		{	*type = SOAP_TYPE__wsdd__Bye;
			return soap_in__wsdd__Bye(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Hello"))
		{	*type = SOAP_TYPE__wsdd__Hello;
			return soap_in__wsdd__Hello(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultTo"))
		{	*type = SOAP_TYPE__wsa__FaultTo;
			return soap_in__wsa__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReplyTo"))
		{	*type = SOAP_TYPE__wsa__ReplyTo;
			return soap_in__wsa__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:From"))
		{	*type = SOAP_TYPE__wsa__From;
			return soap_in__wsa__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelatesTo"))
		{	*type = SOAP_TYPE__wsa__RelatesTo;
			return soap_in__wsa__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReference"))
		{	*type = SOAP_TYPE__wsa__EndpointReference;
			return soap_in__wsa__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdd:Id"))
		{	char **s;
			*type = SOAP_TYPE__wsdd__Id;
			s = soap_in__wsdd__Id(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:SupportedMatchingRules"))
		{	char **s;
			*type = SOAP_TYPE__wsdd__SupportedMatchingRules;
			s = soap_in__wsdd__SupportedMatchingRules(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsdd:XAddrs"))
		{	char **s;
			*type = SOAP_TYPE__wsdd__XAddrs;
			s = soap_in__wsdd__XAddrs(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa__Action;
			s = soap_in__wsa__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa__To;
			s = soap_in__wsa__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa__MessageID;
			s = soap_in__wsa__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if ((!soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__wsdd__MetadataVersion:
		return soap_out__wsdd__MetadataVersion(soap, "wsdd:MetadataVersion", id, (const unsigned int *)ptr, "");
	case SOAP_TYPE__wsa__ReplyAfter:
		return soap_out__wsa__ReplyAfter(soap, "wsa:ReplyAfter", id, (const unsigned int *)ptr, "");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_wsdd__FaultCodeType:
		return soap_out_wsdd__FaultCodeType(soap, tag, id, (const enum wsdd__FaultCodeType *)ptr, "wsdd:FaultCodeType");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_out_wsa__FaultSubcodeValues(soap, tag, id, (const enum wsa__FaultSubcodeValues *)ptr, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_out_wsa__RelationshipTypeValues(soap, tag, id, (const enum wsa__RelationshipTypeValues *)ptr, "wsa:RelationshipTypeValues");
	case SOAP_TYPE__wsdd__AppSequence:
		return soap_out__wsdd__AppSequence(soap, "wsdd:AppSequence", id, (const struct wsdd__AppSequenceType *)ptr, "");
	case SOAP_TYPE__wsdd__Sig:
		return soap_out__wsdd__Sig(soap, "wsdd:Sig", id, (const struct wsdd__SigType *)ptr, "");
	case SOAP_TYPE__wsdd__Security:
		return soap_out__wsdd__Security(soap, "wsdd:Security", id, (const struct wsdd__SecurityType *)ptr, "");
	case SOAP_TYPE__wsdd__Scopes:
		return soap_out__wsdd__Scopes(soap, "wsdd:Scopes", id, (const struct wsdd__ScopesType *)ptr, "");
	case SOAP_TYPE__wsdd__ResolveMatches:
		return soap_out__wsdd__ResolveMatches(soap, "wsdd:ResolveMatches", id, (const struct wsdd__ResolveMatchesType *)ptr, "");
	case SOAP_TYPE__wsdd__Resolve:
		return soap_out__wsdd__Resolve(soap, "wsdd:Resolve", id, (const struct wsdd__ResolveType *)ptr, "");
	case SOAP_TYPE__wsdd__ProbeMatches:
		return soap_out__wsdd__ProbeMatches(soap, "wsdd:ProbeMatches", id, (const struct wsdd__ProbeMatchesType *)ptr, "");
	case SOAP_TYPE__wsdd__Probe:
		return soap_out__wsdd__Probe(soap, "wsdd:Probe", id, (const struct wsdd__ProbeType *)ptr, "");
	case SOAP_TYPE__wsdd__Bye:
		return soap_out__wsdd__Bye(soap, "wsdd:Bye", id, (const struct wsdd__ByeType *)ptr, "");
	case SOAP_TYPE__wsdd__Hello:
		return soap_out__wsdd__Hello(soap, "wsdd:Hello", id, (const struct wsdd__HelloType *)ptr, "");
	case SOAP_TYPE_wsdd__AppSequenceType:
		return soap_out_wsdd__AppSequenceType(soap, tag, id, (const struct wsdd__AppSequenceType *)ptr, "wsdd:AppSequenceType");
	case SOAP_TYPE_wsdd__SigType:
		return soap_out_wsdd__SigType(soap, tag, id, (const struct wsdd__SigType *)ptr, "wsdd:SigType");
	case SOAP_TYPE_wsdd__SecurityType:
		return soap_out_wsdd__SecurityType(soap, tag, id, (const struct wsdd__SecurityType *)ptr, "wsdd:SecurityType");
	case SOAP_TYPE_wsdd__ScopesType:
		return soap_out_wsdd__ScopesType(soap, tag, id, (const struct wsdd__ScopesType *)ptr, "wsdd:ScopesType");
	case SOAP_TYPE_wsdd__ResolveMatchType:
		return soap_out_wsdd__ResolveMatchType(soap, tag, id, (const struct wsdd__ResolveMatchType *)ptr, "wsdd:ResolveMatchType");
	case SOAP_TYPE_wsdd__ResolveMatchesType:
		return soap_out_wsdd__ResolveMatchesType(soap, tag, id, (const struct wsdd__ResolveMatchesType *)ptr, "wsdd:ResolveMatchesType");
	case SOAP_TYPE_wsdd__ResolveType:
		return soap_out_wsdd__ResolveType(soap, tag, id, (const struct wsdd__ResolveType *)ptr, "wsdd:ResolveType");
	case SOAP_TYPE_wsdd__ProbeMatchType:
		return soap_out_wsdd__ProbeMatchType(soap, tag, id, (const struct wsdd__ProbeMatchType *)ptr, "wsdd:ProbeMatchType");
	case SOAP_TYPE_wsdd__ProbeMatchesType:
		return soap_out_wsdd__ProbeMatchesType(soap, tag, id, (const struct wsdd__ProbeMatchesType *)ptr, "wsdd:ProbeMatchesType");
	case SOAP_TYPE_wsdd__ProbeType:
		return soap_out_wsdd__ProbeType(soap, tag, id, (const struct wsdd__ProbeType *)ptr, "wsdd:ProbeType");
	case SOAP_TYPE_wsdd__ByeType:
		return soap_out_wsdd__ByeType(soap, tag, id, (const struct wsdd__ByeType *)ptr, "wsdd:ByeType");
	case SOAP_TYPE_wsdd__HelloType:
		return soap_out_wsdd__HelloType(soap, tag, id, (const struct wsdd__HelloType *)ptr, "wsdd:HelloType");
	case SOAP_TYPE__wsa__FaultTo:
		return soap_out__wsa__FaultTo(soap, "wsa:FaultTo", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__ReplyTo:
		return soap_out__wsa__ReplyTo(soap, "wsa:ReplyTo", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__From:
		return soap_out__wsa__From(soap, "wsa:From", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa__RelatesTo:
		return soap_out__wsa__RelatesTo(soap, "wsa:RelatesTo", id, (const struct wsa__Relationship *)ptr, "");
	case SOAP_TYPE__wsa__EndpointReference:
		return soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", id, (const struct wsa__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa__Relationship:
		return soap_out_wsa__Relationship(soap, tag, id, (const struct wsa__Relationship *)ptr, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_out_wsa__ServiceNameType(soap, tag, id, (const struct wsa__ServiceNameType *)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_out_wsa__ReferenceParametersType(soap, tag, id, (const struct wsa__ReferenceParametersType *)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_out_wsa__ReferencePropertiesType(soap, tag, id, (const struct wsa__ReferencePropertiesType *)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_out_wsa__EndpointReferenceType(soap, tag, id, (const struct wsa__EndpointReferenceType *)ptr, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTowsdd__ResolveMatchesType:
		return soap_out_PointerTowsdd__ResolveMatchesType(soap, tag, id, (struct wsdd__ResolveMatchesType *const*)ptr, "wsdd:ResolveMatchesType");
	case SOAP_TYPE_PointerTowsdd__ResolveType:
		return soap_out_PointerTowsdd__ResolveType(soap, tag, id, (struct wsdd__ResolveType *const*)ptr, "wsdd:ResolveType");
	case SOAP_TYPE_PointerTowsdd__ProbeMatchesType:
		return soap_out_PointerTowsdd__ProbeMatchesType(soap, tag, id, (struct wsdd__ProbeMatchesType *const*)ptr, "wsdd:ProbeMatchesType");
	case SOAP_TYPE_PointerTowsdd__ProbeType:
		return soap_out_PointerTowsdd__ProbeType(soap, tag, id, (struct wsdd__ProbeType *const*)ptr, "wsdd:ProbeType");
	case SOAP_TYPE_PointerTowsdd__ByeType:
		return soap_out_PointerTowsdd__ByeType(soap, tag, id, (struct wsdd__ByeType *const*)ptr, "wsdd:ByeType");
	case SOAP_TYPE_PointerTowsdd__HelloType:
		return soap_out_PointerTowsdd__HelloType(soap, tag, id, (struct wsdd__HelloType *const*)ptr, "wsdd:HelloType");
	case SOAP_TYPE_PointerTowsdd__AppSequenceType:
		return soap_out_PointerTowsdd__AppSequenceType(soap, tag, id, (struct wsdd__AppSequenceType *const*)ptr, "wsdd:AppSequenceType");
	case SOAP_TYPE__wsdd__Id:
		return soap_out_string(soap, "wsdd:Id", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsdd__SupportedMatchingRules:
		return soap_out_string(soap, "wsdd:SupportedMatchingRules", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsdd__XAddrs:
		return soap_out_string(soap, "wsdd:XAddrs", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsdd__Types:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowsdd__SigType:
		return soap_out_PointerTowsdd__SigType(soap, tag, id, (struct wsdd__SigType *const*)ptr, "wsdd:SigType");
	case SOAP_TYPE_PointerTowsdd__ResolveMatchType:
		return soap_out_PointerTowsdd__ResolveMatchType(soap, tag, id, (struct wsdd__ResolveMatchType *const*)ptr, "wsdd:ResolveMatchType");
	case SOAP_TYPE_PointerTowsdd__ProbeMatchType:
		return soap_out_PointerTowsdd__ProbeMatchType(soap, tag, id, (struct wsdd__ProbeMatchType *const*)ptr, "wsdd:ProbeMatchType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTowsdd__ScopesType:
		return soap_out_PointerTowsdd__ScopesType(soap, tag, id, (struct wsdd__ScopesType *const*)ptr, "wsdd:ScopesType");
	case SOAP_TYPE_wsdd__FaultCodeOpenType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsdd:FaultCodeOpenType");
	case SOAP_TYPE_wsdd__UriListType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsdd:UriListType");
	case SOAP_TYPE_wsdd__QNameListType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_out_PointerTo_wsa__FaultTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_out_PointerTo_wsa__From(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, (struct wsa__Relationship *const*)ptr, "wsa:RelatesTo");
	case SOAP_TYPE__wsa__Action:
		return soap_out_string(soap, "wsa:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa__To:
		return soap_out_string(soap, "wsa:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa__MessageID:
		return soap_out_string(soap, "wsa:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_out_PointerTowsa__ServiceNameType(soap, tag, id, (struct wsa__ServiceNameType *const*)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_out_PointerTo_QName(soap, tag, id, (char **const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, (struct wsa__ReferenceParametersType *const*)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_out_PointerTowsa__ReferencePropertiesType(soap, tag, id, (struct wsa__ReferencePropertiesType *const*)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.c\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___tdn__Probe:
		soap_serialize___tdn__Probe(soap, (const struct __tdn__Probe *)ptr);
		break;
	case SOAP_TYPE___tdn__Bye:
		soap_serialize___tdn__Bye(soap, (const struct __tdn__Bye *)ptr);
		break;
	case SOAP_TYPE___tdn__Hello:
		soap_serialize___tdn__Hello(soap, (const struct __tdn__Hello *)ptr);
		break;
	case SOAP_TYPE___wsdd__ResolveMatches:
		soap_serialize___wsdd__ResolveMatches(soap, (const struct __wsdd__ResolveMatches *)ptr);
		break;
	case SOAP_TYPE___wsdd__Resolve:
		soap_serialize___wsdd__Resolve(soap, (const struct __wsdd__Resolve *)ptr);
		break;
	case SOAP_TYPE___wsdd__ProbeMatches:
		soap_serialize___wsdd__ProbeMatches(soap, (const struct __wsdd__ProbeMatches *)ptr);
		break;
	case SOAP_TYPE___wsdd__Probe:
		soap_serialize___wsdd__Probe(soap, (const struct __wsdd__Probe *)ptr);
		break;
	case SOAP_TYPE___wsdd__Bye:
		soap_serialize___wsdd__Bye(soap, (const struct __wsdd__Bye *)ptr);
		break;
	case SOAP_TYPE___wsdd__Hello:
		soap_serialize___wsdd__Hello(soap, (const struct __wsdd__Hello *)ptr);
		break;
	case SOAP_TYPE__wsdd__AppSequence:
		soap_serialize__wsdd__AppSequence(soap, (const struct wsdd__AppSequenceType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Sig:
		soap_serialize__wsdd__Sig(soap, (const struct wsdd__SigType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Security:
		soap_serialize__wsdd__Security(soap, (const struct wsdd__SecurityType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Scopes:
		soap_serialize__wsdd__Scopes(soap, (const struct wsdd__ScopesType *)ptr);
		break;
	case SOAP_TYPE__wsdd__ResolveMatches:
		soap_serialize__wsdd__ResolveMatches(soap, (const struct wsdd__ResolveMatchesType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Resolve:
		soap_serialize__wsdd__Resolve(soap, (const struct wsdd__ResolveType *)ptr);
		break;
	case SOAP_TYPE__wsdd__ProbeMatches:
		soap_serialize__wsdd__ProbeMatches(soap, (const struct wsdd__ProbeMatchesType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Probe:
		soap_serialize__wsdd__Probe(soap, (const struct wsdd__ProbeType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Bye:
		soap_serialize__wsdd__Bye(soap, (const struct wsdd__ByeType *)ptr);
		break;
	case SOAP_TYPE__wsdd__Hello:
		soap_serialize__wsdd__Hello(soap, (const struct wsdd__HelloType *)ptr);
		break;
	case SOAP_TYPE_wsdd__AppSequenceType:
		soap_serialize_wsdd__AppSequenceType(soap, (const struct wsdd__AppSequenceType *)ptr);
		break;
	case SOAP_TYPE_wsdd__SigType:
		soap_serialize_wsdd__SigType(soap, (const struct wsdd__SigType *)ptr);
		break;
	case SOAP_TYPE_wsdd__SecurityType:
		soap_serialize_wsdd__SecurityType(soap, (const struct wsdd__SecurityType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ScopesType:
		soap_serialize_wsdd__ScopesType(soap, (const struct wsdd__ScopesType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ResolveMatchType:
		soap_serialize_wsdd__ResolveMatchType(soap, (const struct wsdd__ResolveMatchType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ResolveMatchesType:
		soap_serialize_wsdd__ResolveMatchesType(soap, (const struct wsdd__ResolveMatchesType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ResolveType:
		soap_serialize_wsdd__ResolveType(soap, (const struct wsdd__ResolveType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ProbeMatchType:
		soap_serialize_wsdd__ProbeMatchType(soap, (const struct wsdd__ProbeMatchType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ProbeMatchesType:
		soap_serialize_wsdd__ProbeMatchesType(soap, (const struct wsdd__ProbeMatchesType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ProbeType:
		soap_serialize_wsdd__ProbeType(soap, (const struct wsdd__ProbeType *)ptr);
		break;
	case SOAP_TYPE_wsdd__ByeType:
		soap_serialize_wsdd__ByeType(soap, (const struct wsdd__ByeType *)ptr);
		break;
	case SOAP_TYPE_wsdd__HelloType:
		soap_serialize_wsdd__HelloType(soap, (const struct wsdd__HelloType *)ptr);
		break;
	case SOAP_TYPE__wsa__FaultTo:
		soap_serialize__wsa__FaultTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		soap_serialize__wsa__ReplyTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__From:
		soap_serialize__wsa__From(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		soap_serialize__wsa__RelatesTo(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		soap_serialize__wsa__EndpointReference(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa__Relationship:
		soap_serialize_wsa__Relationship(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE_wsa__ServiceNameType:
		soap_serialize_wsa__ServiceNameType(soap, (const struct wsa__ServiceNameType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		soap_serialize_wsa__ReferenceParametersType(soap, (const struct wsa__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		soap_serialize_wsa__ReferencePropertiesType(soap, (const struct wsa__ReferencePropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		soap_serialize_wsa__EndpointReferenceType(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ResolveMatchesType:
		soap_serialize_PointerTowsdd__ResolveMatchesType(soap, (struct wsdd__ResolveMatchesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ResolveType:
		soap_serialize_PointerTowsdd__ResolveType(soap, (struct wsdd__ResolveType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ProbeMatchesType:
		soap_serialize_PointerTowsdd__ProbeMatchesType(soap, (struct wsdd__ProbeMatchesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ProbeType:
		soap_serialize_PointerTowsdd__ProbeType(soap, (struct wsdd__ProbeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ByeType:
		soap_serialize_PointerTowsdd__ByeType(soap, (struct wsdd__ByeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__HelloType:
		soap_serialize_PointerTowsdd__HelloType(soap, (struct wsdd__HelloType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__AppSequenceType:
		soap_serialize_PointerTowsdd__AppSequenceType(soap, (struct wsdd__AppSequenceType *const*)ptr);
		break;
	case SOAP_TYPE__wsdd__Id:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsdd__SupportedMatchingRules:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsdd__XAddrs:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsdd__Types:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__SigType:
		soap_serialize_PointerTowsdd__SigType(soap, (struct wsdd__SigType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ResolveMatchType:
		soap_serialize_PointerTowsdd__ResolveMatchType(soap, (struct wsdd__ResolveMatchType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ProbeMatchType:
		soap_serialize_PointerTowsdd__ProbeMatchType(soap, (struct wsdd__ProbeMatchType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdd__ScopesType:
		soap_serialize_PointerTowsdd__ScopesType(soap, (struct wsdd__ScopesType *const*)ptr);
		break;
	case SOAP_TYPE_wsdd__FaultCodeOpenType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsdd__UriListType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsdd__QNameListType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		soap_serialize_PointerTo_wsa__FaultTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		soap_serialize_PointerTo_wsa__ReplyTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__From:
		soap_serialize_PointerTo_wsa__From(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		soap_serialize_PointerTo_wsa__RelatesTo(soap, (struct wsa__Relationship *const*)ptr);
		break;
	case SOAP_TYPE__wsa__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		soap_serialize_PointerTowsa__ServiceNameType(soap, (struct wsa__ServiceNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_QName:
		soap_serialize_PointerTo_QName(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		soap_serialize_PointerTowsa__ReferenceParametersType(soap, (struct wsa__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		soap_serialize_PointerTowsa__ReferencePropertiesType(soap, (struct wsa__ReferencePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__MetadataVersion(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__MetadataVersion(soap, tag ? tag : "wsdd:MetadataVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ReplyAfter(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out__wsa__ReplyAfter(soap, tag ? tag : "wsa:ReplyAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *p;
	unsigned int *a = (unsigned int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(unsigned int));
	for (p = a; p && n--; p++)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsdd__FaultCodeType[] =
{	{ (LONG64)wsdd__MatchingRuleNotSupported, "wsdd:MatchingRuleNotSupported" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsdd__FaultCodeType2s(struct soap *soap, enum wsdd__FaultCodeType n)
{
	const char *s = soap_code_str(soap_codes_wsdd__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsdd__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__FaultCodeType), type) || soap_send(soap, soap_wsdd__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsdd__FaultCodeType(struct soap *soap, const char *s, enum wsdd__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsdd__FaultCodeType, t);
	if (map)
		*a = (enum wsdd__FaultCodeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_in_wsdd__FaultCodeType(struct soap *soap, const char *tag, enum wsdd__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsdd__FaultCodeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsdd__FaultCodeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsdd__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__FaultCodeType, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_new_wsdd__FaultCodeType(struct soap *soap, int n)
{
	enum wsdd__FaultCodeType *p;
	enum wsdd__FaultCodeType *a = (enum wsdd__FaultCodeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsdd__FaultCodeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeType(struct soap *soap, const enum wsdd__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__FaultCodeType(soap, tag ? tag : "wsdd:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_get_wsdd__FaultCodeType(struct soap *soap, enum wsdd__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__FaultSubcodeValues[] =
{	{ (LONG64)wsa__InvalidMessageInformationHeader, "wsa:InvalidMessageInformationHeader" },
	{ (LONG64)wsa__MessageInformationHeaderRequired, "wsa:MessageInformationHeaderRequired" },
	{ (LONG64)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{ (LONG64)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{ (LONG64)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__FaultSubcodeValues2s(struct soap *soap, enum wsa__FaultSubcodeValues n)
{
	const char *s = soap_code_str(soap_codes_wsa__FaultSubcodeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, int id, const enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultSubcodeValues), type) || soap_send(soap, soap_wsa__FaultSubcodeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__FaultSubcodeValues(struct soap *soap, const char *s, enum wsa__FaultSubcodeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__FaultSubcodeValues, t);
	if (map)
		*a = (enum wsa__FaultSubcodeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_in_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__FaultSubcodeValues*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__FaultSubcodeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultSubcodeValues, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_new_wsa__FaultSubcodeValues(struct soap *soap, int n)
{
	enum wsa__FaultSubcodeValues *p;
	enum wsa__FaultSubcodeValues *a = (enum wsa__FaultSubcodeValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__FaultSubcodeValues));
	for (p = a; p && n--; p++)
		soap_default_wsa__FaultSubcodeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultSubcodeValues(struct soap *soap, const enum wsa__FaultSubcodeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__FaultSubcodeValues(soap, tag ? tag : "wsa:FaultSubcodeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_get_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultSubcodeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__RelationshipTypeValues[] =
{	{ (LONG64)wsa__Reply, "wsa:Reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__RelationshipTypeValues2s(struct soap *soap, enum wsa__RelationshipTypeValues n)
{
	const char *s = soap_code_str(soap_codes_wsa__RelationshipTypeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipTypeValues), type) || soap_send(soap, soap_wsa__RelationshipTypeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__RelationshipTypeValues(struct soap *soap, const char *s, enum wsa__RelationshipTypeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__RelationshipTypeValues, t);
	if (map)
		*a = (enum wsa__RelationshipTypeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_in_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipTypeValues*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__RelationshipTypeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipTypeValues, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_new_wsa__RelationshipTypeValues(struct soap *soap, int n)
{
	enum wsa__RelationshipTypeValues *p;
	enum wsa__RelationshipTypeValues *a = (enum wsa__RelationshipTypeValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__RelationshipTypeValues));
	for (p = a; p && n--; p++)
		soap_default_wsa__RelationshipTypeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipTypeValues(struct soap *soap, const enum wsa__RelationshipTypeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__RelationshipTypeValues(soap, tag ? tag : "wsa:RelationshipTypeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_get_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Probe(struct soap *soap, struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ProbeType(soap, &a->tdn__Probe);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Probe, SOAP_TYPE_wsdd__ProbeType);
	soap_serialize_wsdd__ProbeType(soap, &a->tdn__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Probe(struct soap *soap, const char *tag, int id, const struct __tdn__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ProbeType(soap, "tdn:Probe", -1, &a->tdn__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_in___tdn__Probe(struct soap *soap, const char *tag, struct __tdn__Probe *a, const char *type)
{
	size_t soap_flag_tdn__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Probe*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Probe, sizeof(struct __tdn__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Probe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__ProbeType(soap, "tdn:Probe", &a->tdn__Probe, "wsdd:ProbeType"))
				{	soap_flag_tdn__Probe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap_flag_tdn__Probe > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_new___tdn__Probe(struct soap *soap, int n)
{
	struct __tdn__Probe *p;
	struct __tdn__Probe *a = (struct __tdn__Probe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Probe));
	for (p = a; p && n--; p++)
		soap_default___tdn__Probe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Probe(soap, tag ? tag : "-tdn:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_get___tdn__Probe(struct soap *soap, struct __tdn__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Bye(struct soap *soap, struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ByeType(soap, &a->tdn__Bye);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Bye, SOAP_TYPE_wsdd__ByeType);
	soap_serialize_wsdd__ByeType(soap, &a->tdn__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Bye(struct soap *soap, const char *tag, int id, const struct __tdn__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ByeType(soap, "tdn:Bye", -1, &a->tdn__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_in___tdn__Bye(struct soap *soap, const char *tag, struct __tdn__Bye *a, const char *type)
{
	size_t soap_flag_tdn__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Bye*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Bye, sizeof(struct __tdn__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Bye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__ByeType(soap, "tdn:Bye", &a->tdn__Bye, "wsdd:ByeType"))
				{	soap_flag_tdn__Bye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap_flag_tdn__Bye > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_new___tdn__Bye(struct soap *soap, int n)
{
	struct __tdn__Bye *p;
	struct __tdn__Bye *a = (struct __tdn__Bye*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Bye));
	for (p = a; p && n--; p++)
		soap_default___tdn__Bye(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Bye(soap, tag ? tag : "-tdn:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_get___tdn__Bye(struct soap *soap, struct __tdn__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Hello(struct soap *soap, struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__HelloType(soap, &a->tdn__Hello);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Hello, SOAP_TYPE_wsdd__HelloType);
	soap_serialize_wsdd__HelloType(soap, &a->tdn__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Hello(struct soap *soap, const char *tag, int id, const struct __tdn__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__HelloType(soap, "tdn:Hello", -1, &a->tdn__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_in___tdn__Hello(struct soap *soap, const char *tag, struct __tdn__Hello *a, const char *type)
{
	size_t soap_flag_tdn__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Hello*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Hello, sizeof(struct __tdn__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Hello && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__HelloType(soap, "tdn:Hello", &a->tdn__Hello, "wsdd:HelloType"))
				{	soap_flag_tdn__Hello--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap_flag_tdn__Hello > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_new___tdn__Hello(struct soap *soap, int n)
{
	struct __tdn__Hello *p;
	struct __tdn__Hello *a = (struct __tdn__Hello*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Hello));
	for (p = a; p && n--; p++)
		soap_default___tdn__Hello(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Hello(soap, tag ? tag : "-tdn:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_get___tdn__Hello(struct soap *soap, struct __tdn__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ResolveMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveMatchesType(soap, &a->wsdd__ResolveMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ResolveMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ResolveMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", -1, &a->wsdd__ResolveMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_in___wsdd__ResolveMatches(struct soap *soap, const char *tag, struct __wsdd__ResolveMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ResolveMatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__ResolveMatches*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ResolveMatches, sizeof(struct __wsdd__ResolveMatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ResolveMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ResolveMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", &a->wsdd__ResolveMatches, "wsdd:ResolveMatchesType"))
				{	soap_flag_wsdd__ResolveMatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_new___wsdd__ResolveMatches(struct soap *soap, int n)
{
	struct __wsdd__ResolveMatches *p;
	struct __wsdd__ResolveMatches *a = (struct __wsdd__ResolveMatches*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__ResolveMatches));
	for (p = a; p && n--; p++)
		soap_default___wsdd__ResolveMatches(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__ResolveMatches(soap, tag ? tag : "-wsdd:ResolveMatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_get___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ResolveMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Resolve = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveType(soap, &a->wsdd__Resolve);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Resolve(struct soap *soap, const char *tag, int id, const struct __wsdd__Resolve *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", -1, &a->wsdd__Resolve, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_in___wsdd__Resolve(struct soap *soap, const char *tag, struct __wsdd__Resolve *a, const char *type)
{
	size_t soap_flag_wsdd__Resolve = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Resolve*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Resolve, sizeof(struct __wsdd__Resolve), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Resolve(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Resolve && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", &a->wsdd__Resolve, "wsdd:ResolveType"))
				{	soap_flag_wsdd__Resolve--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_new___wsdd__Resolve(struct soap *soap, int n)
{
	struct __wsdd__Resolve *p;
	struct __wsdd__Resolve *a = (struct __wsdd__Resolve*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Resolve));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Resolve(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Resolve(soap, tag ? tag : "-wsdd:Resolve", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_get___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Resolve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ProbeMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ProbeMatchesType(soap, &a->wsdd__ProbeMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ProbeMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ProbeMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", -1, &a->wsdd__ProbeMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_in___wsdd__ProbeMatches(struct soap *soap, const char *tag, struct __wsdd__ProbeMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ProbeMatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__ProbeMatches*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ProbeMatches, sizeof(struct __wsdd__ProbeMatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ProbeMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ProbeMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", &a->wsdd__ProbeMatches, "wsdd:ProbeMatchesType"))
				{	soap_flag_wsdd__ProbeMatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_new___wsdd__ProbeMatches(struct soap *soap, int n)
{
	struct __wsdd__ProbeMatches *p;
	struct __wsdd__ProbeMatches *a = (struct __wsdd__ProbeMatches*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__ProbeMatches));
	for (p = a; p && n--; p++)
		soap_default___wsdd__ProbeMatches(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__ProbeMatches(soap, tag ? tag : "-wsdd:ProbeMatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_get___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ProbeMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Probe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ProbeType(soap, &a->wsdd__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Probe(struct soap *soap, const char *tag, int id, const struct __wsdd__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ProbeType(soap, "wsdd:Probe", -1, &a->wsdd__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_in___wsdd__Probe(struct soap *soap, const char *tag, struct __wsdd__Probe *a, const char *type)
{
	size_t soap_flag_wsdd__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Probe*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Probe, sizeof(struct __wsdd__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Probe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ProbeType(soap, "wsdd:Probe", &a->wsdd__Probe, "wsdd:ProbeType"))
				{	soap_flag_wsdd__Probe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_new___wsdd__Probe(struct soap *soap, int n)
{
	struct __wsdd__Probe *p;
	struct __wsdd__Probe *a = (struct __wsdd__Probe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Probe));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Probe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Probe(soap, tag ? tag : "-wsdd:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_get___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Bye = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ByeType(soap, &a->wsdd__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Bye(struct soap *soap, const char *tag, int id, const struct __wsdd__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ByeType(soap, "wsdd:Bye", -1, &a->wsdd__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_in___wsdd__Bye(struct soap *soap, const char *tag, struct __wsdd__Bye *a, const char *type)
{
	size_t soap_flag_wsdd__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Bye*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Bye, sizeof(struct __wsdd__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Bye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ByeType(soap, "wsdd:Bye", &a->wsdd__Bye, "wsdd:ByeType"))
				{	soap_flag_wsdd__Bye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_new___wsdd__Bye(struct soap *soap, int n)
{
	struct __wsdd__Bye *p;
	struct __wsdd__Bye *a = (struct __wsdd__Bye*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Bye));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Bye(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Bye(soap, tag ? tag : "-wsdd:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_get___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Hello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__HelloType(soap, &a->wsdd__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Hello(struct soap *soap, const char *tag, int id, const struct __wsdd__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__HelloType(soap, "wsdd:Hello", -1, &a->wsdd__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_in___wsdd__Hello(struct soap *soap, const char *tag, struct __wsdd__Hello *a, const char *type)
{
	size_t soap_flag_wsdd__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Hello*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Hello, sizeof(struct __wsdd__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Hello && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__HelloType(soap, "wsdd:Hello", &a->wsdd__Hello, "wsdd:HelloType"))
				{	soap_flag_wsdd__Hello--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_new___wsdd__Hello(struct soap *soap, int n)
{
	struct __wsdd__Hello *p;
	struct __wsdd__Hello *a = (struct __wsdd__Hello*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Hello));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Hello(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Hello(soap, tag ? tag : "-wsdd:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_get___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__AppSequence(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__AppSequence(soap, tag ? tag : "wsdd:AppSequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Sig(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Sig(soap, tag ? tag : "wsdd:Sig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Security(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Security(soap, tag ? tag : "wsdd:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Scopes(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Scopes(soap, tag ? tag : "wsdd:Scopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__ResolveMatches(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__ResolveMatches(soap, tag ? tag : "wsdd:ResolveMatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Resolve(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Resolve(soap, tag ? tag : "wsdd:Resolve", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__ProbeMatches(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__ProbeMatches(soap, tag ? tag : "wsdd:ProbeMatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Probe(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Probe(soap, tag ? tag : "wsdd:Probe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Bye(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Bye(soap, tag ? tag : "wsdd:Bye", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Hello(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Hello(soap, tag ? tag : "wsdd:Hello", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->InstanceId);
	soap_default_string(soap, &a->SequenceId);
	soap_default_unsignedInt(soap, &a->MessageNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__AppSequenceType(struct soap *soap, const char *tag, int id, const struct wsdd__AppSequenceType *a, const char *type)
{
	soap_set_attr(soap, "InstanceId", soap_unsignedInt2s(soap, a->InstanceId), 1);
	if (a->SequenceId)
		soap_set_attr(soap, "SequenceId", soap_string2s(soap, a->SequenceId), 1);
	soap_set_attr(soap, "MessageNumber", soap_unsignedInt2s(soap, a->MessageNumber), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__AppSequenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_in_wsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__AppSequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__AppSequenceType(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "InstanceId", 5, 3), &a->InstanceId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SequenceId", 1, 0), &a->SequenceId))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MessageNumber", 5, 3), &a->MessageNumber))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__AppSequenceType, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_new_wsdd__AppSequenceType(struct soap *soap, int n)
{
	struct wsdd__AppSequenceType *p;
	struct wsdd__AppSequenceType *a = (struct wsdd__AppSequenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__AppSequenceType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__AppSequenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__AppSequenceType(soap, tag ? tag : "wsdd:AppSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_get_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SigType(struct soap *soap, struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Scheme);
	soap_default_string(soap, &a->KeyId);
	soap_default_string(soap, &a->Refs);
	soap_default_string(soap, &a->Sig);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SigType(struct soap *soap, const char *tag, int id, const struct wsdd__SigType *a, const char *type)
{
	soap_set_attr(soap, "Scheme", a->Scheme ? soap_string2s(soap, a->Scheme) : "", 1);
	if (a->KeyId)
		soap_set_attr(soap, "KeyId", soap_string2s(soap, a->KeyId), 1);
	soap_set_attr(soap, "Refs", a->Refs ? soap_string2s(soap, a->Refs) : "", 1);
	soap_set_attr(soap, "Sig", a->Sig ? soap_string2s(soap, a->Sig) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SigType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_in_wsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__SigType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SigType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Scheme", 1, 3), &a->Scheme))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "KeyId", 1, 0), &a->KeyId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Refs", 1, 3), &a->Refs))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Sig", 1, 3), &a->Sig))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SigType, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_new_wsdd__SigType(struct soap *soap, int n)
{
	struct wsdd__SigType *p;
	struct wsdd__SigType *a = (struct wsdd__SigType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__SigType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__SigType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__SigType(soap, tag ? tag : "wsdd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_get_wsdd__SigType(struct soap *soap, struct wsdd__SigType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__SigType(soap, &a->Sig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SecurityType(struct soap *soap, const char *tag, int id, const struct wsdd__SecurityType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SecurityType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__SigType(soap, "wsdd:Sig", -1, &a->Sig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_in_wsdd__SecurityType(struct soap *soap, const char *tag, struct wsdd__SecurityType *a, const char *type)
{
	size_t soap_flag_Sig = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__SecurityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SecurityType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sig && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__SigType(soap, "wsdd:Sig", &a->Sig, "wsdd:SigType"))
				{	soap_flag_Sig--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SecurityType, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_new_wsdd__SecurityType(struct soap *soap, int n)
{
	struct wsdd__SecurityType *p;
	struct wsdd__SecurityType *a = (struct wsdd__SecurityType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__SecurityType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__SecurityType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__SecurityType(soap, tag ? tag : "wsdd:SecurityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_get_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SecurityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__UriListType(soap, &a->__item);
	soap_default_string(soap, &a->MatchBy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ScopesType(struct soap *soap, const char *tag, int id, const struct wsdd__ScopesType *a, const char *type)
{
	if (a->MatchBy)
		soap_set_attr(soap, "MatchBy", soap_string2s(soap, a->MatchBy), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__UriListType(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_in_wsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsdd__ScopesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsdd__ScopesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MatchBy", 1, 0), &a->MatchBy))
		return NULL;
	if (!soap_in_wsdd__UriListType(soap, tag, (char**)&a->__item, "wsdd:ScopesType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_new_wsdd__ScopesType(struct soap *soap, int n)
{
	struct wsdd__ScopesType *p;
	struct wsdd__ScopesType *a = (struct wsdd__ScopesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ScopesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ScopesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ScopesType(soap, tag ? tag : "wsdd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_get_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchType, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_new_wsdd__ResolveMatchType(struct soap *soap, int n)
{
	struct wsdd__ResolveMatchType *p;
	struct wsdd__ResolveMatchType *a = (struct wsdd__ResolveMatchType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveMatchType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveMatchType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveMatchType(soap, tag ? tag : "wsdd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResolveMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveMatchType(soap, &a->ResolveMatch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchesType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", -1, &a->ResolveMatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType *a, const char *type)
{
	size_t soap_flag_ResolveMatch = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResolveMatch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", &a->ResolveMatch, "wsdd:ResolveMatchType"))
				{	soap_flag_ResolveMatch--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchesType, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_new_wsdd__ResolveMatchesType(struct soap *soap, int n)
{
	struct wsdd__ResolveMatchesType *p;
	struct wsdd__ResolveMatchesType *a = (struct wsdd__ResolveMatchesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveMatchesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveMatchesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveMatchesType(soap, tag ? tag : "wsdd:ResolveMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveType), type))
		return soap->error;
	soap_element_result(soap, "wsa:EndpointReference");
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_in_wsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			soap_check_result(soap, "wsa:EndpointReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa__EndpointReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveType, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_new_wsdd__ResolveType(struct soap *soap, int n)
{
	struct wsdd__ResolveType *p;
	struct wsdd__ResolveType *a = (struct wsdd__ResolveType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveType(soap, tag ? tag : "wsdd:ResolveType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_get_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchType, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_new_wsdd__ProbeMatchType(struct soap *soap, int n)
{
	struct wsdd__ProbeMatchType *p;
	struct wsdd__ProbeMatchType *a = (struct wsdd__ProbeMatchType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeMatchType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeMatchType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeMatchType(soap, tag ? tag : "wsdd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProbeMatch = 0;
	a->ProbeMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
		{
			soap_embedded(soap, a->ProbeMatch + i, SOAP_TYPE_wsdd__ProbeMatchType);
			soap_serialize_wsdd__ProbeMatchType(soap, a->ProbeMatch + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchesType), type))
		return soap->error;
	soap_element_result(soap, "-sizeProbeMatch");
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
			if (soap_out_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", -1, a->ProbeMatch + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType *a, const char *type)
{
	struct soap_blist *soap_blist_ProbeMatch = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsdd:ProbeMatch", 1, NULL))
			{	if (a->ProbeMatch == NULL)
				{	if (soap_blist_ProbeMatch == NULL)
						soap_blist_ProbeMatch = soap_alloc_block(soap);
					a->ProbeMatch = (struct wsdd__ProbeMatchType *)soap_push_block_max(soap, soap_blist_ProbeMatch, sizeof(struct wsdd__ProbeMatchType));
					if (a->ProbeMatch == NULL)
						return NULL;
					soap_default_wsdd__ProbeMatchType(soap, a->ProbeMatch);
				}
				soap_revert(soap);
				if (soap_in_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", a->ProbeMatch, "wsdd:ProbeMatchType"))
				{	a->__sizeProbeMatch++;
					a->ProbeMatch = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProbeMatch");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ProbeMatch)
			soap_pop_block(soap, soap_blist_ProbeMatch);
		if (a->__sizeProbeMatch)
		{	a->ProbeMatch = (struct wsdd__ProbeMatchType *)soap_save_block(soap, soap_blist_ProbeMatch, NULL, 1);
		}
		else
		{	a->ProbeMatch = NULL;
			if (soap_blist_ProbeMatch)
				soap_end_block(soap, soap_blist_ProbeMatch);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchesType, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_new_wsdd__ProbeMatchesType(struct soap *soap, int n)
{
	struct wsdd__ProbeMatchesType *p;
	struct wsdd__ProbeMatchesType *a = (struct wsdd__ProbeMatchesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeMatchesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeMatchesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeMatchesType(soap, tag ? tag : "wsdd:ProbeMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeType), type))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_in_wsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType *a, const char *type)
{
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeType, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_new_wsdd__ProbeType(struct soap *soap, int n)
{
	struct wsdd__ProbeType *p;
	struct wsdd__ProbeType *a = (struct wsdd__ProbeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeType(soap, tag ? tag : "wsdd:ProbeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_get_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	a->MetadataVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_serialize_PointerTounsignedInt(soap, &a->MetadataVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ByeType(struct soap *soap, const char *tag, int id, const struct wsdd__ByeType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ByeType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_in_wsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ByeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ByeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa__EndpointReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ByeType, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_new_wsdd__ByeType(struct soap *soap, int n)
{
	struct wsdd__ByeType *p;
	struct wsdd__ByeType *a = (struct wsdd__ByeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ByeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ByeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ByeType(soap, tag ? tag : "wsdd:ByeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_get_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__HelloType(struct soap *soap, const char *tag, int id, const struct wsdd__HelloType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__HelloType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_in_wsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__HelloType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__HelloType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__HelloType, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_new_wsdd__HelloType(struct soap *soap, int n)
{
	struct wsdd__HelloType *p;
	struct wsdd__HelloType *a = (struct wsdd__HelloType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__HelloType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__HelloType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__HelloType(soap, tag ? tag : "wsdd:HelloType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_get_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->wsdd__AppSequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__MessageID(soap, (char*const*)&a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, (char*const*)&a->wsa__To);
	soap_serialize__wsa__Action(soap, (char*const*)&a->wsa__Action);
	soap_serialize_PointerTowsdd__AppSequenceType(soap, &a->wsdd__AppSequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, (char*const*)&a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, (char*const*)&a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, (char*const*)&a->wsa__Action, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", -1, &a->wsdd__AppSequence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	size_t soap_flag_wsdd__AppSequence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__MessageID(soap, "wsa:MessageID", (char**)&a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__To(soap, "wsa:To", (char**)&a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__Action(soap, "wsa:Action", (char**)&a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			}
			if (soap_flag_wsdd__AppSequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", &a->wsdd__AppSequence, "wsdd:AppSequenceType"))
				{	soap_flag_wsdd__AppSequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__FaultTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__FaultTo(soap, tag ? tag : "wsa:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ReplyTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__ReplyTo(soap, tag ? tag : "wsa:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__From(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__From(soap, tag ? tag : "wsa:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__RelatesTo(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	if (soap_out__wsa__RelatesTo(soap, tag ? tag : "wsa:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__EndpointReference(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__EndpointReference(soap, tag ? tag : "wsa:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap__QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "RelationshipType", 2, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_new_wsa__Relationship(struct soap *soap, int n)
{
	struct wsa__Relationship *p;
	struct wsa__Relationship *a = (struct wsa__Relationship*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__Relationship));
	for (p = a; p && n--; p++)
		soap_default_wsa__Relationship(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	if (soap_out_wsa__Relationship(soap, tag ? tag : "wsa:Relationship", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item;
	soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", soap_string2s(soap, a->PortName), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out__QName(soap, tag, id, (char*const*)(void*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 1, 0), &a->PortName))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in__QName(soap, tag, (char**)&a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_new_wsa__ServiceNameType(struct soap *soap, int n)
{
	struct wsa__ServiceNameType *p;
	struct wsa__ServiceNameType *a = (struct wsa__ServiceNameType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ServiceNameType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ServiceNameType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_new_wsa__ReferenceParametersType(struct soap *soap, int n)
{
	struct wsa__ReferenceParametersType *p;
	struct wsa__ReferenceParametersType *a = (struct wsa__ReferenceParametersType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ReferenceParametersType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ReferenceParametersType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__ReferencePropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_new_wsa__ReferencePropertiesType(struct soap *soap, int n)
{
	struct wsa__ReferencePropertiesType *p;
	struct wsa__ReferencePropertiesType *a = (struct wsa__ReferencePropertiesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ReferencePropertiesType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ReferencePropertiesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType;
	soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa:Address"))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)(void*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_new_wsa__EndpointReferenceType(struct soap *soap, int n)
{
	struct wsa__EndpointReferenceType *p;
	struct wsa__EndpointReferenceType *a = (struct wsa__EndpointReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__EndpointReferenceType));
	for (p = a; p && n--; p++)
		soap_default_wsa__EndpointReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchesType))
		soap_serialize_wsdd__ResolveMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, tag ? tag : "wsdd:ResolveMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveType))
		soap_serialize_wsdd__ResolveType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveType **)soap_malloc(soap, sizeof(struct wsdd__ResolveType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveType(soap, tag ? tag : "wsdd:ResolveType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchesType))
		soap_serialize_wsdd__ProbeMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, tag ? tag : "wsdd:ProbeMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeType))
		soap_serialize_wsdd__ProbeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeType **)soap_malloc(soap, sizeof(struct wsdd__ProbeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeType(soap, tag ? tag : "wsdd:ProbeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ByeType))
		soap_serialize_wsdd__ByeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ByeType(struct soap *soap, const char *tag, int id, struct wsdd__ByeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ByeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ByeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ByeType **)soap_malloc(soap, sizeof(struct wsdd__ByeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ByeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ByeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ByeType(soap, tag ? tag : "wsdd:ByeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__HelloType))
		soap_serialize_wsdd__HelloType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__HelloType(struct soap *soap, const char *tag, int id, struct wsdd__HelloType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__HelloType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__HelloType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_in_PointerTowsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__HelloType **)soap_malloc(soap, sizeof(struct wsdd__HelloType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__HelloType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__HelloType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__HelloType(soap, tag ? tag : "wsdd:HelloType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_get_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__AppSequenceType))
		soap_serialize_wsdd__AppSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, int id, struct wsdd__AppSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__AppSequenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__AppSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_in_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__AppSequenceType **)soap_malloc(soap, sizeof(struct wsdd__AppSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__AppSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__AppSequenceType(soap, tag ? tag : "wsdd:AppSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_get_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Id(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Id(soap, tag ? tag : "wsdd:Id", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__SigType))
		soap_serialize_wsdd__SigType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__SigType(struct soap *soap, const char *tag, int id, struct wsdd__SigType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__SigType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__SigType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_in_PointerTowsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__SigType **)soap_malloc(soap, sizeof(struct wsdd__SigType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__SigType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__SigType(soap, tag ? tag : "wsdd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_get_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchType))
		soap_serialize_wsdd__ResolveMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, tag ? tag : "wsdd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchType))
		soap_serialize_wsdd__ProbeMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeMatchType(soap, tag ? tag : "wsdd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ScopesType))
		soap_serialize_wsdd__ScopesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, int id, struct wsdd__ScopesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ScopesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ScopesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ScopesType **)soap_malloc(soap, sizeof(struct wsdd__ScopesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ScopesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ScopesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ScopesType(soap, tag ? tag : "wsdd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsdd__FaultCodeOpenType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsdd__FaultCodeOpenType(soap, tag ? tag : "wsdd:FaultCodeOpenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__FaultCodeOpenType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeOpenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__UriListType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsdd__UriListType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__UriListType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__UriListType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__UriListType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__UriListType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__UriListType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsdd__UriListType(soap, tag ? tag : "wsdd:UriListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__UriListType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__UriListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__FaultTo))
		soap_serialize__wsa__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__FaultTo(soap, tag ? tag : "wsa:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__ReplyTo))
		soap_serialize__wsa__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__ReplyTo(soap, tag ? tag : "wsa:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__From))
		soap_serialize__wsa__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__From(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__From(soap, tag ? tag : "wsa:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__RelatesTo))
		soap_serialize__wsa__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa__Relationship *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_in_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__Relationship **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__Relationship **)soap_malloc(soap, sizeof(struct wsa__Relationship *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__Relationship **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__Relationship), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa__RelatesTo(soap, tag ? tag : "wsa:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_get_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa__Action(soap, tag ? tag : "wsa:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa__To(soap, tag ? tag : "wsa:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa__MessageID(soap, tag ? tag : "wsa:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ServiceNameType))
		soap_serialize_wsa__ServiceNameType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, int id, struct wsa__ServiceNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ServiceNameType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ServiceNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_in_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ServiceNameType **)soap_malloc(soap, sizeof(struct wsa__ServiceNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ServiceNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_get_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__QName))
		soap_serialize__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		soap_serialize_wsa__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferencePropertiesType))
		soap_serialize_wsa__ReferencePropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, struct wsa__ReferencePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferencePropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferencePropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferencePropertiesType **)soap_malloc(soap, sizeof(struct wsa__ReferencePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferencePropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *p;
	char * *a = (char **)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char *));
	for (p = a; p && n--; p++)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
